// programs must contain at least 1 expression, and expressions are obligated to be separated by whitespace
#program = #w* #block_inner #w*;  

// whitespace/other ignored rules
#line_comment = '/\/' '\n'~* / '\n'~;
//TODO->block comments aren't correct yet...
//#block_comment = '/\{' 
//    (#block_comment_inner #block_comment #block_comment_inner)+ | 
//    #block_comment_inner
//'}/';
//#block_comment_inner = (ξ* / [/}]~) - (ξ* '/\{' ξ* '}/' ξ*);                 // block comments can have nested block comments
#comment = #line_comment;// | #block_comment;
#whitespace = [\x20\n];                                     // only valid whitespace is space and newline
#w = #whitespace | #comment;
#s = ' ';                                                   // non-breaking space

#reserved = #unit | #keyword;
#keyword = {in} | {as} | {loop} | {if} | {and} | {or} | {xor} | {nand} | {nor} | {xnor} | {true} | {false}; 


//////// Expressions ////////
// this will be a very long list
#expr = 
    #tid | #literal | #container | #block | #loop | #if >
    #call | #access >
    #unary_expr >
    #math_expr >
    #shift_expr >
    #compare_expr >
    #logical_expr >
    #coalesce >
    #in >
    #assign | #points_to;


#block = #scope_block | #noscope_block;
#scope_block = '{' #w* (#block_inner #w*)? '}';
#noscope_block = '(' #w* (#block_inner #w*)? ')';
#block_inner = #expr (#w+ #expr)*;


#literal = #int_literal | #bool_literal | #string | #func_literal | #range_literal;

#id = ([a-zA-Z_] [0-9a-zA-Z_?!$&]* / [0-9a-zA-Z_?!$&]) - #reserved;
//(('loop' | 'in' | 'if') | #unit);//#reserved;


#call = #callable_expr '(' #w* (#call_args #w*)? ')';
#callable_expr = #id | #func_literal | #access;
#call_args = #expr (#w* ',' #w* #expr)*;  //includes assignment expressions

//TODO->unpack assignment/unpack in
#assign = (#tid | #access | #unpack) #w* '=' #w* (#expr - #assign);
#in = (#id | #unpack) #w* 'in' #w* (#expr - #in);
//bug causes infinite recursion because #points_to_operand is used...
#points_to = #points_to_left | #points_to_right | #points_to_both;
#points_to_right = (#expr - #points_to) #w* '->' #w* (#expr - #points_to);
#points_to_left = (#expr - #points_to) #w* '<-' #w* (#expr - #points_to);
#points_to_both = (#expr - #points_to) #w* '<->' #w* (#expr - #points_to);
//#points_to_operand = #expr - #points_to;

#unpack = '[' #w* (#unpack_item (#w* ',' #w* #unpack_item)* #w*)? ']';
#unpack_item = #as | #id | #collect | #unpack;
#as = #id #w* {as} #w* (#id | #unpack);
#collect = '...' #id;

#access = #name_access | #map_access;
#name_access = #accessible_expr #w* '.' #w* #id;
#map_access = #accessible_expr '[' #w* #expr #w* ']';
#accessible_expr = #expr - (#if | #in | #loop);

#compare_expr = (#expr - #compare_expr) #w* #compare_op #w* (#expr - #compare_expr);
#compare_op = '>?' | '<?' | '>=?' | '<=?' | '=?' | '!=?';

#math_expr = #pow > #mul | #div | #mod > #add | #sub;
#add = #expr #w* '+' #w* (#expr - (#add | #sub));
#sub = #expr #w* '-' #w* (#expr - (#add | #sub));
//#jux = #atom #s* #atom;
#mul = #expr #w* '*' #w* (#expr - (#mul | #div | #mod));
#div = #expr #w* '/' #w* (#expr - (#mul | #div | #mod));
#mod = #expr #w* '%' #w* (#expr - (#mul | #div | #mod));
#pow = (#expr - #pow) #w* '^' #w* #expr;



//#atom = #group | #id | #num;
//#group = '(' #w* #expr. #w* ')';



#shift_expr = #shift_left | #shift_right | #rotate_left | #rotate_right | #rotate_left_with_carry | #rotate_right_with_carry;
#shift_left = #expr #w* '<<' #w* (#expr - #shift_expr);
#shift_right = #expr #w* '>>' #w* (#expr - #shift_expr);
#rotate_left = #expr #w* '<<<' #w* (#expr - #shift_expr);
#rotate_right = #expr #w* '>>>' #w* (#expr - #shift_expr);
#rotate_left_with_carry = #expr #w* '<<<!' #w* (#expr - #shift_expr);
#rotate_right_with_carry = #expr #w* '!>>>' #w* (#expr - #shift_expr);

#coalesce = #expr #w* '??' #w* #expr;

#unary_expr = #not | #fact;
#not = 'not' #w* #expr;
#fact = #expr #w* '!';

#logical_expr = #and | #or | #xor | #nand | #nor | #xnor; 
#and = #expr #w* {and} #w* (#expr - #logical_expr);
#or = #expr #w* {or} #w* (#expr - #logical_expr);
#xor = #expr #w* {xor} #w* (#expr - #logical_expr);
#nand = #expr #w* {nand} #w* (#expr - #logical_expr);
#nor = #expr #w* {nor} #w* (#expr - #logical_expr);
#xnor = #expr #w* {xnor} #w* (#expr - #logical_expr);


//#loop = {loop} #w* (#id | #id_tuple) #w* {in} #w* #expr #w* #expr;
#loop = {loop} #w* #expr #w* #expr;

//TODO->else/else if
#if = {if} #w* #expr #w* #expr;

//////// Literals ////////
// strings with interpolation and comments
#string = #double_string | #single_string;
#double_string = '"' (#double_string_text | #escape | #string_interp | #comment)* '"';
#double_string_text = (["{}\\]~+ / ["{}\\]~) - (#string_interp | #comment);
#single_string = "'" (#single_string_text | #escape | #string_interp | #comment)* "'";
#single_string_text = (['{}\\]~+ / ['{}\\]~) - (#string_interp | #comment);
#string_interp = '{' #w* #expr #w* '}';
#escape = '\\' ξ;

// integer strings. TODO: add more bases
#binary_string = '0' {b} [01] [01_]* / [01_];
#octal_string = '0' {o} [0-7] [0-7_]* / [0-7_];
#decimal_string = ('0' {d})? [0-9] [0-9_]* / [0-9_];
#hexadecimal_string = '0' {x} [0-9A-Fa-f] [0-9A-Fa-f_]* / [0-9A-Fa-f_];

#int_literal = #binary_string | #octal_string | #decimal_string | #hexadecimal_string;

#bool_literal = {true} | {false};

// TODO->replace id with optionally typed id
#type_spec = ':' #w* #type_expr;
#tid = #id #type_spec?;
#tid_tuple = #tid #w* ',' (#w* #tid #w* ',')* (#w* #tid)?;
#id_tuple = #id #w* ',' (#w* #id #w* ',')* (#w* #id)?;

#type_expr = #id | #generic_type; //TODO->more type expressions
#generic_type = #type_expr '<' #w* (#tid | #tid_tuple) #w* '>';

#func_literal_head = '(' #w* #tid_tuple #w* ')' | #tid;
#func_literal = #func_literal_head #w* '=>' #w* #expr; 

//Compact way of specifying units. Doesn't return parse tree containing which prefix/unit though..
#unit = (#prefix_symbol)? #unit_symbol | (#prefix_name)? #unit_name;
#prefix_symbol = [YZEPTGMkcmuμnpfazy];
#unit_symbol = [gmsAK] | 'cd' | 'mol';
#prefix_name = {yotta} | {zetta} | {exa} | {peta} | {tera} | {giga} | {mega} | {kilo} | {centi} | {milli} | {micro} | {nano} | {pico} | {femto} | {atto} | {zepto} | {yocto};
#unit_name = {gram}{s}? | {meter}{s}? | {metre}{s}? | {second}{s}? | {amp}{s}? | {ampere}{s}? | {kelvin} | {mol}{s}? | {mole}{s}? | {candela}{s}?;


//TODO->figure out bug where both left/right expressions can't be #range_endpoint, else infinite recursion
//TODO->make left and right side of range optional (e.g. ..10, 10.., ..), with the unspecified side being -inf/inf
//#partial_range = (range_endpoint #w*)? '..' (#w* range_endpoint)?;
#range_literal = [\[(] #w* #range_core [\])] | #range_core;
#range_core = #range_endpoint #w* '..' #w* (#expr - (#range_literal | #assign | #in));
#range_endpoint = #expr - (#range_literal | #assign | #in);

#container = '[' #w* (#block_inner #w*)? ']';

/{
TODO:
- math op chaining
---> important that precedence is determined by the first symbol in the op chain.
        probably have mirrors of each op with a chain version, or perhaps put the op chain in the original expression itself
- math unary expressions (are these op chainable? idk some might be, e.g. /-2 for 1/-2?)

- type expressions
---> more possible expressions
- math expressions
    - vector element-wise operations
- assignments
    - destructuring assignments
    - update assignments
- accessor methods (e.g. by index, by value, by field)
- literals
    - integer
    - float
    - arrays
    - ranges
    - function
- units + unit expressions

}/