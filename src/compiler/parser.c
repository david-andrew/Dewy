#ifndef PARSER_C
#define PARSER_C

#include <stdio.h>
#include <stdlib.h>
// #include <inttypes.h> // for PRIu64

#include "charset.h"
#include "metaparser.h"
#include "parser.h"
#include "set.h"

/**
 * Global data structures used by the parser
 * Slots are a head ::= rule, with a dot starting the rule, or following a non-terminals)
 */
vect* parser_labels;
// TODO->come up with better names for these globals
// set* P;
// set* Y;
// set* R;
// set* U;
uint32_t* I;
uint64_t cI;
uint64_t cU;
// CRF* crf;
// struct {
//     vect* labels;
//     set* P;
//     set* Y;
//     set* R;
//     set* U;
//     uint32_t* I;
//     uint64_t cI;
//     uint64_t cU;
//     // CRF* crf;
// } parser_context = {};

// Y, U, R, I, cI, cU, crf

void initialize_parser()
{
    parser_labels = new_vect();
    // other initializations here
}

void release_parser()
{
    vect_free(parser_labels);
    // other frees here
}

/**
 * Generate the list of labels (slots) used by the CNP algorithm for the current grammar
 */
void parser_generate_labels()
{
    // iterate over the list of productions in the metaparser
    dict* productions = metaparser_get_productions();
    for (size_t i = 0; i < dict_size(productions); i++)
    {
        obj head_idx_obj;
        obj bodies_set_obj;
        dict_get_at_index(productions, i, &head_idx_obj, &bodies_set_obj);
        uint64_t head_idx = *(uint64_t*)head_idx_obj.data;
        set* bodies = (set*)bodies_set_obj.data;

        for (size_t body_idx = 0; body_idx < set_size(bodies); body_idx++)
        {
            vect* body = metaparser_get_production_body(head_idx, body_idx);

            slot s = slot_struct(head_idx, body_idx, 0);

            // add the initial item for the production to the list of labels
            vect_append(parser_labels, new_slot_obj(slot_copy(&s)));

            // iterate over the slot until the dot is at the end of the production
            for (s.position = 1; s.position <= vect_size(body); s.position++)
            {
                uint64_t* symbol_idx = vect_get(body, s.position - 1)->data;
                // if the symbol before the dot is a non-terminal, add a new slot
                if (!metaparser_is_symbol_terminal(*symbol_idx))
                {
                    vect_append(parser_labels, new_slot_obj(slot_copy(&s)));
                }
            }
        }
    }
}

/**
 * return the list of labels generated by the parser for the current grammar
 */
vect* parser_get_labels() { return parser_labels; }

/**
 * perform the CNP parsing actions for the given label
 */
void parser_handle_label(slot* label)
{
    // keep track of the current position in the item without modifying the original
    uint64_t dot = label->position;

    vect* body = metaparser_get_production_body(label->head_idx, label->production_idx);
    if (label->position == 0 && vect_size(body) == 0)
    {
        // Y.add((SubTerm(label.head, Sentence([])), cI, cI, cI))
    }
    else
    {
        while (dot < vect_size(body))
        {
            if (!metaparser_is_symbol_terminal(*(uint64_t*)vect_get(body, dot)->data)) { break; }
            if (dot != 0)
            {
                slice s = slice_struct(body, dot, vect_size(body), NULL);
                if (!parser_test_select(I[cI], label->head_idx, &s)) { return; }
            }
            dot++;

            parser_bsr_add(slot_copy(label), cU, cI, cI + 1);
            cI++;
        }

        if (dot < vect_size(body))
        {
            if (dot != 0)
            {
                slice s = slice_struct(body, dot, vect_size(body), NULL);
                if (!parser_test_select(I[cI], label->head_idx, &s)) { return; }
            }
            dot++;
            parser_call(slot_copy(label), cU, cI);
        }
    }

    if (label->position == vect_size(body) ||
        (dot == vect_size(body) && metaparser_is_symbol_terminal(*(uint64_t*)vect_get(body, dot - 1)->data)))
    {
        // get the followset of the label head
        fset* follow = metaparser_follow_of_symbol(label->head_idx);
        if (fset_contains_c(follow, I[cI]))
        {
            parser_return(label->head_idx, cU, cI);
            return;
        }
    }
}

/**
 * print the CNP actions performed for the given label
 */
void parser_print_label(slot* label)
{
    slot_str(label);
    printf("\n");

    // keep track of the current position in the item without modifying the original
    uint64_t dot = label->position;

    vect* body = metaparser_get_production_body(label->head_idx, label->production_idx);
    if (label->position == 0 && vect_size(body) == 0)
    {
        printf("    Y.add((SubTerm(label.head, Sentence([])), cI, cI, cI))\n");
    }
    else
    {
        while (dot < vect_size(body))
        {
            if (!metaparser_is_symbol_terminal(*(uint64_t*)vect_get(body, dot)->data)) { break; }
            if (dot != 0)
            {
                slice s = slice_struct(body, dot, vect_size(body), NULL);
                printf("    if (!parser_test_select(I[cI], ");
                obj_str(metaparser_get_symbol(label->head_idx));
                printf(", ");
                metaparser_print_body_slice(&s);
                printf("))\n        goto L0\n");
            }
            dot++;
            printf("    parser_bsr_add(");
            slot_str(&(slot){label->head_idx, label->production_idx, dot});
            printf(", cU, cI, cI + 1);\n    cI += 1\n");
        }

        if (dot < vect_size(body))
        {
            if (dot != 0)
            {
                slice s = slice_struct(body, dot, vect_size(body), NULL);
                printf("    if (!parser_test_select(I[cI], ");
                obj_str(metaparser_get_symbol(label->head_idx));
                printf(", ");
                metaparser_print_body_slice(&s);
                printf("))\n        goto L0\n");
            }
            dot++;
            printf("    parser_call(");
            slot_str(&(slot){label->head_idx, label->production_idx, dot});
            printf(", cU, cI);\n");
        }
    }

    if (label->position == vect_size(body) ||
        (dot == vect_size(body) && metaparser_is_symbol_terminal(*(uint64_t*)vect_get(body, dot - 1)->data)))
    {
        printf("    if (I[cI] ∈ follow(");
        obj_str(metaparser_get_symbol(label->head_idx));
        printf("))\n        rtn(");
        obj_str(metaparser_get_symbol(label->head_idx));
        printf(", cU, cI);\n");
    }
    printf("    goto L0\n");
}

/**
 * TODO->what is this function for?
 */
void parser_nt_add(uint64_t head_idx, uint64_t j)
{
    set* bodies = metaparser_get_production_bodies(head_idx);
    for (size_t production_idx = 0; production_idx < set_size(bodies); production_idx++)
    {
        vect* body = set_get_at_index(bodies, production_idx)->data;
        slice s = slice_struct(body, 0, vect_size(body), NULL);
        if (parser_test_select(I[j], head_idx, &s)) { parser_dsc_add(&(slot){head_idx, production_idx, 0}, j, j); }
    }
}

/**
 * TODO->what is this function for?
 */
bool parser_test_select(uint32_t c, uint64_t head_idx, slice* string)
{
    fset* first = metaparser_first_of_string(string);
    bool result = false;
    if (fset_contains_c(first, c)) { result = true; }
    else if (first->special)
    {
        fset* follow = metaparser_follow_of_symbol(head_idx);
        if (fset_contains_c(follow, c)) { result = true; }
    }

    // free fset allocated by first of string
    fset_free(first); // TODO->allocate all of these so that fset of string can return an owned fset
                      // e.g. have first_of_string_memoized() which can only return strings seen in first_of_string()
    return result;
}

/**
 * TODO->what is this function for?
 * creates a copy of the slot if it is to be inserted. Original is not modified.
 */
void parser_dsc_add(slot* slot, uint64_t k, uint64_t j)
{
    // TODO->convert the slot to a slot_idx
    // create a static 3 tuple containing (slot, k, j)
    // if tuple not in U, add copy(tuple) to U and R
}

/**
 * TODO->what is this function for?
 */
void parser_return(uint64_t head_idx, uint64_t k, uint64_t j)
{
    // create static 3 tuple (head_idx, k, j)
    // check if tuple not in P
    // if not, add tuple to P
    //   and for each child v of (head_idx, k) in the CRF
    //     let (L, i) be the label of v
    //     dsc_add(L, i, j)
    //     bsr_add(L, i, k, j)
}

/**
 * TODO->what is this function for?
 */
void parser_call(slot* slot, uint64_t i, uint64_t j)
{
    // suppose that L is Y ::= αX · β
    // if there is no CRF node labelled (L, i) create one
    // let u be the CRF node labelled (L, i)
    // if there is no CRF node labelled (X, j) {
    //   create a CRF node v labelled (X, j)
    //   create an edge from v to u
    //   ntAdd(X, j) }
    // else { let v be the CRF node labelled (X, j)
    //   if there is not an edge from v to u {
    //     create an edge from v to u
    //     for all ((X, j, h) ∈ P) {
    //       dscAdd(L, i, h); bsrAdd(L, i, j, h) } } } }
}

/**
 * TODO->what is this function for?
 */
void parser_bsr_add(slot* slot, uint64_t i, uint64_t k, uint64_t j)
{
    vect* body = metaparser_get_production_body(slot->head_idx, slot->production_idx);
    if (vect_size(body) == slot->position)
    {
        // insert (head_idx, production_idx, i, k, j) into Y
    }
    else if (slot->position > 1)
    {
        // slice s = slice_struct(body, 0, slot->position, NULL);
        // insert (s, i, k, j) into Y
    }
}

#endif