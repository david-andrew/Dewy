#ifndef PARSER_C
#define PARSER_C

#include <stdio.h>
#include <stdlib.h>
// #include <inttypes.h> // for PRIu64

#include "metaparser.h"
#include "parser.h"
#include "set.h"

/**
 * Global data structures used by the parser
 * Slots are a head ::= rule, with a dot starting the rule, or following a non-terminals)
 */

vect* parser_labels;

void initialize_parser()
{
    parser_labels = new_vect();
    // other initializations here
}

void release_parser()
{
    vect_free(parser_labels);
    // other frees here
}

/**
 * Generate the list of labels (slots) used by the CNP algorithm for the current grammar
 */
void parser_generate_labels()
{
    // iterate over the list of productions in the metaparser
    dict* productions = metaparser_get_productions();
    for (size_t i = 0; i < dict_size(productions); i++)
    {
        obj head_idx_obj;
        obj bodies_set_obj;
        dict_get_at_index(productions, i, &head_idx_obj, &bodies_set_obj);
        uint64_t head_idx = *(uint64_t*)head_idx_obj.data;
        set* bodies = (set*)bodies_set_obj.data;

        for (size_t body_idx = 0; body_idx < set_size(bodies); body_idx++)
        {
            vect* body = metaparser_get_production_body(head_idx, body_idx);

            slot s = slot_struct(head_idx, body_idx, 0);

            // add the initial item for the production to the list of labels
            vect_append(parser_labels, new_slot_obj(slot_copy(&s)));

            // iterate over the slot until the dot is at the end of the production
            for (s.position = 1; s.position <= vect_size(body); s.position++)
            {
                uint64_t* symbol_idx = vect_get(body, s.position - 1)->data;
                // if the symbol before the dot is a non-terminal, add a new slot
                if (!metaparser_is_symbol_terminal(*symbol_idx))
                {
                    vect_append(parser_labels, new_slot_obj(slot_copy(&s)));
                }
            }
        }
    }
}

/**
 * return the list of labels generated by the parser for the current grammar
 */
vect* parser_get_labels() { return parser_labels; }

// P, Y, R, U, cI, cU

#endif