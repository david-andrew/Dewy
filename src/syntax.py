from abc import ABC, abstractmethod, ABCMeta
from typing import Generator, Iterable, Any
from dataclasses import dataclass, field
from enum import Enum, auto

from .tokenizer import escape_whitespace  # TODO: move into utils

import pdb


def anonyname[T](gen: Iterable[T], count: bool = False) -> Generator[tuple[str, T], None, None]:
    """
    Pair up members of a generator with an anonymous name.
    If count is True, the name will be the index of the item in the generator
    Otherwise, the name will be an empty string

    Args:
        gen: Generator[T, None, None] - the generator to pair with names
        count: bool - whether to use the index as the name

    Returns:
        Generator[tuple[str, T], None, None]: a generator of tuples with the name
    """
    if count:
        yield from ((f'{i}', item) for i, item in enumerate(gen))
    else:
        yield from ((f'', item) for item in gen)


class ASTMeta(ABCMeta):
    """
    Metaclass for AST abstract class
    - automatically applies the dataclass decorator with repr=False to concrete AST subclasses
    - ensures that __iter__ is not overwritten by any child classes
    """
    def __new__(cls, name, bases, dct):
        # ensure that __iter__ is not overwritten by any child classes
        if ABC not in bases and '__iter__' in dct:
            raise AttributeError(
                f'cannot overwrite __iter__() in class {name}(AST). Please overwrite __full_iter__() instead'
            )

        new_cls = super().__new__(cls, name, bases, dct)

        # apply the dataclass decorator with repr=False to all AST classes
        if ABC not in bases:
            new_cls = dataclass(repr=False)(new_cls)

        return new_cls


@dataclass(repr=False)
class AST(ABC, metaclass=ASTMeta):
    # TODO: add property to all ASTs for function complete/locked/etc. meaning it and all children are settled
    @abstractmethod
    def __str__(self) -> str:
        """Return a string representation of the AST in a canonical dewy code format"""

    def __repr__(self) -> str:
        """
        Returns a string representation of the AST tree with correct indentation for each sub-component

        e.g. 
        SomeAST(prop0=..., prop1=...)
        ├── child0=SomeSubAST(...)
        ├── child1=SomeOtherAST(...)
        │   ├── a=ThisAST(...)
        │   └── b=ThatAST(...)
        └── child2=AST2(...)
            └── something=ThisLastAST(...)

        Where all non-ast attributes of a node are printed on the same line as the node itself
        and all children are recursively indented a level and printed on their own line
        """
        return '\n'.join(self._gentree())

    def _gentree(self, prefix: str = '') -> Generator[str, None, None]:
        """
        a recursive generator helper function for __repr__

        Args:
            prefix: str - the string to prepend to each child line (root line already has prefix)
            name: str - the name of the current node in the tree
            # draw_branches: bool - whether each item should be drawn with branches or only use whitespace

        Returns:
            str: the string representation of the AST tree
        """
        # prefix components:
        space = '    '
        branch = '│   '
        # pointers:
        tee = '├── '
        last = '└── '

        attrs_str = ', '.join(f'{k}={v}' for k, v in self.__full_iter__() if not isinstance(v, AST))
        yield f'{self.__class__.__name__}({attrs_str})'
        children = tuple((k, v) for k, v in self.__full_iter__() if isinstance(v, AST))
        pointers = [tee] * (len(children) - 1) + [last]
        for (k, v), pointer in zip(children, pointers):
            extension = branch if pointer == tee else space
            gen = v._gentree(f'{prefix}{extension}')
            name = f'{k}=' if k else ''
            yield f'{prefix}{pointer}{name}{next(gen)}'     # first line gets name and pointer
            yield from gen                                  # rest of lines already have a prefix

    def __full_iter__(self) -> Generator[tuple[str, Any], None, None]:
        """A method for getting all properties on the AST instance.
        All child AST types should be generated by this process.
        __iter__ makes use of this function to get all children ASTs
        """
        yield from self.__dict__.items()

    def __iter__(self) -> Generator['AST', None, None]:
        """Return a generator of the children of the AST"""
        for _, child in self.__full_iter__():
            if isinstance(child, AST):
                yield child

    def is_settled(self) -> bool:
        """Return True if the neither the AST, nor any of its children, are prototypes"""
        for child in self:
            if not child.is_settled():
                return False
        return True


class PrototypeAST(AST, ABC):
    """Used to represent AST nodes that are not complete, and must be removed before the whole AST is evaluated"""

    def is_settled(self) -> bool:
        """By definition, prototypes are not settled"""
        return False


class Type(AST):
    name: str
    parameters: list = field(default_factory=list)

    def __str__(self) -> str:
        if self.parameters:
            return f'{self.name}<{", ".join(map(str, self.parameters))}>'
        return self.name


# TODO: turn into a singleton...
# untyped type for when a declaration doesn't specify a type
untyped = Type('untyped')


class Undefined(AST):
    """undefined singleton"""
    def __new__(cls):
        if not hasattr(cls, 'instance'):
            cls.instance = super(Undefined, cls).__new__(cls)
        return cls.instance

    def __str__(self) -> str:
        return 'undefined'


# undefined shorthand, for convenience
undefined = Undefined()


class Void(AST):
    """void singleton"""
    def __new__(cls):
        if not hasattr(cls, 'instance'):
            cls.instance = super(Void, cls).__new__(cls)
        return cls.instance

    def __str__(self) -> str:
        return 'void'


# void shorthand, for convenience
void = Void()


class Identifier(AST):
    name: str

    def __str__(self) -> str:
        return f'{self.name}'


class TypedIdentifier(AST):
    id: Identifier
    type: Type

    def __str__(self) -> str:
        return f'{self.id}:{self.type}'


class UnpackTarget(AST):
    def __str__(self):
        target: list[Identifier | UnpackTarget]
        raise NotImplementedError('UnpackTarget is not implemented yet')


class DeclarationType(Enum):
    LET = auto()
    CONST = auto()
    LOCAL_CONST = auto()

    # default for binding without declaring
    DEFAULT = LET


class Declare(AST):
    decltype: DeclarationType
    target: Identifier | TypedIdentifier | UnpackTarget

    def __str__(self):
        return f'{self.decltype.name.lower()} {self.target}'


class Assign(AST):
    # TODO: allow bind to take in an unpack structure
    target: Declare | Identifier | UnpackTarget
    value: AST

    def __str__(self):
        return f'{self.target} = {self.value}'


class ListOfASTs(PrototypeAST):
    """Intermediate step for holding a list of ASTs that are probably captured by a container"""
    asts: list[AST]

    def __str__(self):
        return f'{", ".join(map(str, self.asts))}'

    def __full_iter__(self) -> Generator[tuple[str, AST], None, None]:
        yield from anonyname(self.asts)


class Array(AST):
    items: list[AST]

    def __str__(self):
        return f'[{", ".join(map(str, self.items))}]'

    def __full_iter__(self) -> Generator[tuple[str, AST], None, None]:
        yield from anonyname(self.items)


class String(AST):
    val: str

    def __str__(self) -> str:
        return f'"{escape_whitespace(self.val)}"'


class IString(AST):
    parts: list[AST]

    def __str__(self):
        s = ''
        for part in self.parts:
            if isinstance(part, String):
                s += part.val
            else:
                s += f'{{{part}}}'
        return f'"{s}"'

    def __full_iter__(self) -> Generator[AST, None, None]:
        yield from anonyname(self.parts)


# class FunctionLiteral(AST):
#     args: list[Declare]
#     kwargs: list[Bind]
#     body: AST


if __name__ == '__main__':
    # DEBUG testing tree string printing
    class Add(AST):
        l: AST
        r: AST

        def __str__(self) -> str:
            return f'{self.l} + {self.r}'

    class Mul(AST):
        l: AST
        r: AST

        def __str__(self) -> str:
            return f'{self.l} * {self.r}'

    class List(AST):
        items: list[AST]

        def __str__(self) -> str:
            return f'[{", ".join(map(str, self.items))}]'

        def __full_iter__(self) -> Generator[tuple[str, Any], None, None]:
            yield from (('', v) for v in self.items)

    class Int(AST):
        value: int

        def __str__(self) -> str:
            return str(self.value)

    # big long test ast
    test = Add(
        Add(
            Int(1),
            List([Int(2), Int(3), Int(4), Int(5)])
        ),
        Mul(
            Int(2),
            Add(
                Mul(
                    Int(3),
                    Int(4)
                ),
                Mul(
                    Int(5),
                    Int(6)
                )
            )
        )
    )

    print(repr(test))
    # class Broken(AST):
    #     num: int
    #     def __str__(self) -> str:
    #         return f'{self.num}'
    #     def __iter__(self) -> Generator['AST', None, None]:
    #         yield Int(self.num)
