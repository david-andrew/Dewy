from abc import ABC, abstractmethod, ABCMeta
from typing import Generator, Iterable, Any, Literal, Type as TypingType, dataclass_transform, Callable as TypingCallable
from dataclasses import dataclass, field
from enum import Enum, auto
# from fractions import Fraction

from .tokenizer import Operator_t, escape_whitespace  # TODO: move into utils

import pdb


def anonyname[T](gen: Iterable[T], count: bool = False) -> Generator[tuple[str, T], None, None]:
    """
    Pair up members of a generator with an anonymous name.
    If count is True, the name will be the index of the item in the generator
    Otherwise, the name will be an empty string

    Args:
        gen: Generator[T, None, None] - the generator to pair with names
        count: bool - whether to use the index as the name

    Returns:
        Generator[tuple[str, T], None, None]: a generator of tuples with the name
    """
    if count:
        yield from ((f'{i}', item) for i, item in enumerate(gen))
    else:
        yield from ((f'', item) for item in gen)


@dataclass_transform()
class AST(ABC):
    def __init_subclass__(cls: TypingType['AST'], **kwargs):
        """
        - automatically applies the dataclass decorator with repr=False to AST subclasses
        - ensures that __iter__ is not overwritten by any child classes
        """
        super().__init_subclass__(**kwargs)
        # Check if __iter__ is overridden in the subclass (not including AST itself)
        if '__iter__' in cls.__dict__ and cls.__name__ != 'AST':
            raise AttributeError(
                f"cannot overwrite __iter__() in class {cls.__name__}(AST). Please overwrite __full_iter__() instead"
            )
        # Apply the dataclass decorator with repr=False to the subclass
        dataclass(repr=False)(cls)

    # TODO: add property to all ASTs for function complete/locked/etc. meaning it and all children are settled
    @abstractmethod
    def __str__(self) -> str:
        """Return a string representation of the AST in a canonical dewy code format"""

    def __repr__(self) -> str:
        """
        Returns a string representation of the AST tree with correct indentation for each sub-component

        e.g.
        SomeAST(prop0=..., prop1=...)
        ├── child0=SomeSubAST(...)
        ├── child1=SomeOtherAST(...)
        │   ├── a=ThisAST(...)
        │   └── b=ThatAST(...)
        └── child2=AST2(...)
            └── something=ThisLastAST(...)

        Where all non-ast attributes of a node are printed on the same line as the node itself
        and all children are recursively indented a level and printed on their own line
        """
        return '\n'.join(self._gentree())

    def _gentree(self, prefix: str = '') -> Generator[str, None, None]:
        """
        a recursive generator helper function for __repr__

        Args:
            prefix: str - the string to prepend to each child line (root line already has prefix)
            name: str - the name of the current node in the tree
            # draw_branches: bool - whether each item should be drawn with branches or only use whitespace

        Returns:
            str: the string representation of the AST tree
        """
        # prefix components:
        space = '    '
        branch = '│   '
        # pointers:
        tee = '├── '
        last = '└── '

        attrs_str = ', '.join(f'{k}={v}' for k, v in self.__full_iter__() if not isinstance(v, AST))
        yield f'{self.__class__.__name__}({attrs_str})'
        children = tuple((k, v) for k, v in self.__full_iter__() if isinstance(v, AST))
        pointers = [tee] * (len(children) - 1) + [last]
        for (k, v), pointer in zip(children, pointers):
            extension = branch if pointer == tee else space
            gen = v._gentree(f'{prefix}{extension}')
            name = f'{k}=' if k else ''
            yield f'{prefix}{pointer}{name}{next(gen)}'     # first line gets name and pointer
            yield from gen                                  # rest of lines already have a prefix

    def __full_iter__(self) -> Generator[tuple[str, Any], None, None]:
        """A method for getting all properties on the AST instance.
        All child AST types should be generated by this process.
        __iter__ makes use of this function to get all children ASTs
        """
        yield from self.__dict__.items()

    def __iter__(self) -> Generator['AST', None, None]:
        """Return a generator of the children of the AST"""
        for _, child in self.__full_iter__():
            if isinstance(child, AST):
                yield child

    def is_settled(self) -> bool:
        """Return True if the neither the AST, nor any of its children, are prototypes"""
        for child in self:
            if not child.is_settled():
                return False
        return True


class PrototypeAST(AST, ABC):
    """Used to represent AST nodes that are not complete, and must be removed before the whole AST is evaluated"""

    def is_settled(self) -> bool:
        """By definition, prototypes are not settled"""
        return False


class Delimited(ABC):
    """used to track which ASTs are printed with their own delimiter so they can be juxtaposed without extra parentheses"""

class Type(AST):
    name: str
    parameters: list = field(default_factory=list)

    def __str__(self) -> str:
        if self.parameters:
            return f'{self.name}<{", ".join(map(str, self.parameters))}>'
        return self.name


# TODO: turn into a singleton...
# untyped type for when a declaration doesn't specify a type
untyped = Type('untyped')


class Undefined(AST):
    """undefined singleton"""
    def __new__(cls):
        if not hasattr(cls, 'instance'):
            cls.instance = super(Undefined, cls).__new__(cls)
        return cls.instance

    def __str__(self) -> str:
        return 'undefined'


# undefined shorthand, for convenience
undefined = Undefined()


class Void(AST):
    """void singleton"""
    def __new__(cls):
        if not hasattr(cls, 'instance'):
            cls.instance = super(Void, cls).__new__(cls)
        return cls.instance

    def __str__(self) -> str:
        return 'void'


# void shorthand, for convenience
void = Void()


# assign is just a binop?
# perhaps bring this one back since it's syntax that distinguishes it, not type checking
# class Assign(AST):
#     # TODO: allow bind to take in an unpack structure
#     target: Declare | Identifier | UnpackTarget
#     value: AST

#     def __str__(self):
#         return f'{self.target} = {self.value}'


class ListOfASTs(PrototypeAST):
    """Intermediate step for holding a list of ASTs that are probably captured by a container"""
    asts: list[AST]

    def __str__(self):
        return f'{", ".join(map(str, self.asts))}'

    def __full_iter__(self) -> Generator[tuple[str, Any], None, None]:
        yield from anonyname(self.asts)

class Tuple(PrototypeAST):
    """
    A comma separated list of expressions (not wrapped in parentheses) e.g. 1, 2, 3
    There is no special in-memory representation of a tuple, it is literally just a const list
    """
    items: list[AST]

    def __str__(self):
        return f'{", ".join(map(str, self.items))}'

    def __full_iter__(self) -> Generator[tuple[str, Any], None, None]:
        yield from anonyname(self.items)


# class Container(PrototypeAST, Delimited):
#     items: list[AST]
#     brackets: Literal['{}', '[]', '(]', '[)', '()', '<>']

#     def __str__(self):
#         return f'{self.brackets[0]}{" ".join(map(str, self.items))}{self.brackets[1]}'

#     def __full_iter__(self) -> Generator[tuple[str, Any], None, None]:
#         yield ('brackets', self.brackets)
#         yield from anonyname(self.items)


# class Number(AST):
#     val: int | float | Fraction

class Bool(AST):
    val: bool

    def __str__(self) -> str:
        return str(self.val).lower()


class Int(AST):
    val: int

    def __str__(self) -> str:
        return str(self.val)


class String(AST, Delimited):
    val: str

    def __str__(self) -> str:
        return f'"{escape_whitespace(self.val)}"'


class IString(AST, Delimited):
    parts: list[AST]

    def __str__(self):
        s = ''
        for part in self.parts:
            if isinstance(part, String):
                s += part.val
            else:
                s += f'{part}'
        return f'"{s}"'

    def __full_iter__(self) -> Generator[tuple[str, Any], None, None]:
        yield from anonyname(self.parts)


class Flowable(AST, ABC):
    ...
    # def was_entered(self) -> bool:
    #     """Determine if the flowable branch was entered. Should reset before performing calls to flow and checking this."""
    #     raise NotImplementedError(f'flowables must implement `was_entered()`. No implementation found for {self.__class__}')

    # def reset_was_entered(self) -> None:
    #     """reset the state of was_entered, in preparation for executing branches in a flow"""
    #     raise NotImplementedError(f'flowables must implement `reset_was_entered()`. No implementation found for {self.__class__}')


class Flow(AST):
    branches: list[Flowable]

    def __str__(self):
        return ' else '.join(map(str, self.branches))

    def __full_iter__(self) -> Generator[tuple[str, Any], None, None]:
        yield from anonyname(self.branches)


class If(Flowable):
    condition: AST
    body: AST

    def __str__(self):
        return f'if {self.condition} {self.body}'


class Loop(Flowable):
    condition: AST
    body: AST

    def __str__(self):
        return f'loop {self.condition} {self.body}'


class Default(Flowable):
    body: AST

    def __str__(self):
        return f'{self.body}'


class FunctionLiteral(AST):
    args: AST
    body: AST

    def __str__(self):
        if isinstance(self.args, Delimited):
            return f'{self.args} => {self.body}'
        return f'({self.args}) => {self.body}'


class PrototypePyAction(PrototypeAST):
    args: AST
    return_type: AST

    def __str__(self):
        return f'({self.args}): {self.return_type} => ...'

class PyAction(AST):
    args: AST
    action: TypingCallable
    return_type: AST

    def __str__(self):
        return f'({self.args}): {self.return_type} => {self.action}'


class Call(AST):
    f: AST
    args: None | AST = None

    def __str__(self):
        if self.args is None:
            return f'{self.f}()'
        if isinstance(self.args, Delimited):
            return f'{self.f}{self.args}'
        return f'{self.f}({self.args})'


class BinOp(AST, ABC):
    left: AST
    right: AST

class Assign(BinOp):
    def __str__(self): return f'{self.left} = {self.right}'

class PointsTo(BinOp):
    def __str__(self): return f'{self.left} -> {self.right}'

class BidirPointsTo(BinOp):
    def __str__(self): return f'{self.left} <-> {self.right}'

class Access(BinOp):
    def __str__(self): return f'{self.left}.{self.right}'

class Equal(BinOp):
    def __str__(self): return f'{self.left} =? {self.right}'

# covered by OpChain([Not, Equal])
# class NotEqual(BinOp):
#     def __str__(self): return f'{self.left} not=? {self.right}'

class Less(BinOp):
    def __str__(self): return f'{self.left} <? {self.right}'

class LessEqual(BinOp):
    def __str__(self): return f'{self.left} <=? {self.right}'

class Greater(BinOp):
    def __str__(self): return f'{self.left} >? {self.right}'

class GreaterEqual(BinOp):
    def __str__(self): return f'{self.left} >=? {self.right}'

class  LeftShift(BinOp):
    def __str__(self): return f'{self.left} << {self.right}'

class  RightShift(BinOp):
    def __str__(self): return f'{self.left} >> {self.right}'

class LeftRotate(BinOp):
    def __str__(self): return f'{self.left} <<< {self.right}'

class RightRotate(BinOp):
    def __str__(self): return f'{self.left} >>> {self.right}'

class LeftRotateCarry(BinOp):
    def __str__(self): return f'{self.left} <<! {self.right}'

class RightRotateCarry(BinOp):
    def __str__(self): return f'{self.left} !>> {self.right}'

class Add(BinOp):
    def __str__(self): return f'{self.left} + {self.right}'

class Sub(BinOp):
    def __str__(self): return f'{self.left} - {self.right}'

class Mul(BinOp):
    def __str__(self): return f'{self.left} * {self.right}'

class Div(BinOp):
    def __str__(self): return f'{self.left} / {self.right}'

class IDiv(BinOp):
    def __str__(self): return f'{self.left} ÷ {self.right}'

class Mod(BinOp):
    def __str__(self): return f'{self.left} % {self.right}'

class Pow(BinOp):
    def __str__(self): return f'{self.left} ^ {self.right}'

class And(BinOp):
    def __str__(self): return f'{self.left} and {self.right}'

class Or(BinOp):
    def __str__(self): return f'{self.left} or {self.right}'

class Xor(BinOp):
    def __str__(self): return f'{self.left} xor {self.right}'

class Nand(BinOp):
    def __str__(self): return f'{self.left} nand {self.right}'

class Nor(BinOp):
    def __str__(self): return f'{self.left} nor {self.right}'

class Xnor(BinOp):
    def __str__(self): return f'{self.left} xnor {self.right}'

class IterIn(BinOp):
    def __str__(self): return f'{self.left} in {self.right}'

class MemberIn(BinOp):
    def __str__(self): return f'{self.left} in? {self.right}'

class UnaryPrefixOp(AST, ABC):
    operand: AST

class Not(UnaryPrefixOp):
    def __str__(self): return f'not {self.operand}'

class UnaryNeg(UnaryPrefixOp):
    def __str__(self): return f'-{self.operand}'

class UnaryPos(UnaryPrefixOp):
    def __str__(self): return f'+{self.operand}'

class UnaryMul(UnaryPrefixOp):
    def __str__(self): return f'*{self.operand}'

class UnaryDiv(UnaryPrefixOp):
    def __str__(self): return f'/{self.operand}'


class UnaryPostfixOp(AST, ABC):
    operand: AST


class Group(AST, Delimited):
    items: list[AST]

    def __str__(self):
        return f'({" ".join(map(str, self.items))})'

    def __full_iter__(self):
        yield from anonyname(self.items)


class Block(AST, Delimited):
    items: list[AST]

    def __str__(self):
        return f'{{{" ".join(map(str, self.items))}}}'

    def __full_iter__(self):
        yield from anonyname(self.items)


class BareRange(PrototypeAST):
    left: AST
    right: AST

    def __str__(self) -> str:
        return f'{self.left}..{self.right}'


class Ellipsis(AST):
    def __str__(self) -> str:
        return '...'


class Spread(AST):
    right: AST

    def __str__(self) -> str:
        return f'...{self.right}'


class Range(AST):
    left: AST
    right: AST
    brackets: Literal['[]', '[)', '(]', '()']

    def __str__(self) -> str:
        return f'{self.brackets[0]}{self.left}..{self.right}{self.brackets[1]}'


class Array(AST, Delimited):
    items: list[AST] # list[T] where T is not Declare or Assign or PointsTo or BidirPointsTo

    def __str__(self):
        return f'[{" ".join(map(str, self.items))}]'

    def __full_iter__(self):
        yield from anonyname(self.items)


class Dict(AST, Delimited):
    items: list[PointsTo]

    def __str__(self):
        return f'[{" ".join(map(str, self.items))}]'

    def __full_iter__(self):
        yield from anonyname(self.items)


class BidirDict(AST, Delimited):
    items: list[BidirPointsTo]

    def __str__(self):
        return f'[{" ".join(map(str, self.items))}]'

    def __full_iter__(self):
        yield from anonyname(self.items)


class Object(AST, Delimited):
    items: list[AST] # list[Declare|Assign|AST] has to have at least 1 declare or assignment

    def __str__(self):
        return f'[{" ".join(map(str, self.items))}]'

    def __full_iter__(self):
        yield from anonyname(self.items)


class TypeParam(AST, Delimited):
    items: list[AST]

    def __str__(self):
        return f'<{" ".join(map(str, self.items))}>'

    def __full_iter__(self):
        yield from anonyname(self.items)


class DeclareGeneric(AST):
    left: TypeParam
    right: AST

    def __str__(self):
        return f'{self.left}{self.right}'


class Parameterize(AST):
    left: AST
    right: TypeParam

    def __str__(self):
        return f'{self.left}{self.right}'


#TODO: maybe this should just be a binop, i.e. does right need to be restricted to Range|Array?
# perhaps keep since to parse an index, the right must be a Range|Array
class Index(AST):
    left: AST
    right: Range | Array

    def __str__(self):
        return f'{self.left}{self.right}'


class PrototypeIdentifier(PrototypeAST):
    name: str
    def __str__(self) -> str:
        return f'{self.name}'

class Identifier(AST):
    name: str
    def __str__(self) -> str:
        return f'{self.name}'


class Express(AST):
    id: Identifier

    def __str__(self) -> str:
        return f'{self.id}'

class TypedIdentifier(AST):
    id: Identifier
    type: AST

    def __str__(self) -> str:
        return f'{self.id}:{self.type}'


class TypedGroup(AST):
    group: Group
    type: AST

    def __str__(self) -> str:
        return f'{self.group}:{self.type}'

class SequenceUnpackTarget(AST):
    target: 'list[Identifier | SequenceUnpackTarget | ObjectUnpackTarget | Spread]'
    def __str__(self) -> str:
        return f'{" ".join(map(str, self.target))}'

class ObjectUnpackTarget(AST):
    target: 'list[Identifier | Assign | SequenceUnpackTarget | ObjectUnpackTarget | Spread]'
    def __str__(self) -> str:
        return f'{" ".join(map(str, self.target))}'

# class UnpackTarget(AST):
#     target: 'list[Identifier | UnpackTarget | Spread]'
#     def __str__(self):
#         raise NotImplementedError('UnpackTarget is not implemented yet')


class DeclarationType(Enum):
    LET = auto()
    CONST = auto()
    # LOCAL_CONST = auto()
    # FIXED_TYPE = auto()

    # default for binding without declaring
    # DEFAULT = LET


class Declare(AST):
    decltype: DeclarationType
    target: Identifier | TypedIdentifier | TypedGroup | SequenceUnpackTarget | ObjectUnpackTarget | Assign

    def __str__(self):
        return f'{self.decltype.name.lower()} {self.target}'



if __name__ == '__main__':
    # DEBUG testing tree string printing
    class _Add(AST):
        l: AST
        r: AST

        def __str__(self) -> str:
            return f'{self.l} + {self.r}'

    class _Mul(AST):
        l: AST
        r: AST

        def __str__(self) -> str:
            return f'{self.l} * {self.r}'

    class _List(AST):
        items: list[AST]

        def __str__(self) -> str:
            return f'[{", ".join(map(str, self.items))}]'

        def __full_iter__(self) -> Generator[tuple[str, Any], None, None]:
            yield from (('', v) for v in self.items)

    class _Int(AST):
        value: int

        def __str__(self) -> str:
            return str(self.value)

    # big long test ast
    test = _Add(
        _Add(
            _Int(1),
            _List([_Int(2), _Int(3), _Int(4), _Int(5)])
        ),
        _Mul(
            _Int(2),
            _Add(
                _Mul(
                    _Int(3),
                    _Int(4)
                ),
                _Mul(
                    _Int(5),
                    _Int(6)
                )
            )
        )
    )

    print(repr(test))
    print(str(test))
    # class Broken(AST):
    #     num: int
    #     def __str__(self) -> str:
    #         return f'{self.num}'
    #     def __iter__(self) -> Generator['AST', None, None]:
    #         yield Int(self.num)
