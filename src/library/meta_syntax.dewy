//http://www.engr.mun.ca/~theo/Courses/fm/pub/context-free.pdf
//https://www.w3.org/TR/xml/#sec-notation
//https://en.wikipedia.org/wiki/Whitespace_character

//Most of these should be purely character sets...

#eps = \x3f5;                                               // Ïµ indicates empty element, i.e. nullable
#wschars = [\x9-\xD\x20\x85\xA0\x1680\x2000-\x200A\x2028\x2029\x202F\x205F\x3000];
#ws = #wschars*;                                            //optional whitespace sequence
#any = '\\' [uUxX];                                         // \U, \u, \X, or \x used to indicate any unicode character
#hex = '\\' [uUxX] [0-9a-fA-F]+;                            // hex number literal. Basically skipping the number part makes it #any
#charsetchar = \U - [\-\[\]] - #ws;                         // characters allowed in a set are any unicode excluding '-', '[', or ']', and whitespace
#item = #charsetchar | #escape | #hex;                      // items that make up character sets, i.e. raw chars, escape chars, or hex chars
#charset = '[' (#ws #item (#ws '-' #ws #item)? #ws)* ']';   // set of chars specified literally. Whitespace is ignored, and must be escaped.

//paired grouping operators
#group = '(' #ws #expr #ws ')';                             // group together/force precedence
#capture = '{' #ws #expr #ws '}';                           // group to capture
#char = '"' (\U - '"' | #escape) '"';                       // single character
#char = "'" (\U - "'" | #escape) "'";                       // single character
#string = '"' (\U - '"' | #escape)* '"';                    // "" string of characters
#string = "'" (\U - "'" | #escape)* "'";                    // '' string of characters
#escape = '\\' (\U - [uUxX]);                               // an escape character. Recognized escaped characters are \n \r \t \v \b \f \a. All others just put the second character literally. Common literals include \\ \' \" \[ \] \-

//post operators
#star = #expr #ws '*';                                      // zero or more
#plus = #expr #ws '+';                                      // one or more
#option = #expr #ws '?';                                    // optional
#compliment = #set #ws '~'                                  // compliment of. equivalent to #any - #set

//implicit operators
#cat = #expr (#ws #expr)+;                                  // concatenate left and right

//binary operators
#diff = #set #ws '-' #ws #set;                              // left but not right. TBD if only for charsets... could modify parser to allow for #expr here, where if both sides are matched, then it doesn't match...
#intersect = #set #ws '&' #ws #set;                         // intersect of left and right
#union = #set #ws | #ws #set;                               // union of left and right

#or = #expr #ws '|' #ws #expr;                              // left or right

//syntax constructs
#set = #any | #char | #hex | #charset | #hexset | #compliment | #diff | #intersect | #union;
#expr = #eps | #set | #group | #capture | #string | #star | #plus | #option | #cat | #or | #identifier;
#identifier = '#' [a-zA-Z0-9!@#$?&_]*;
#rule = #identifier #ws '=' #ws #expr #ws ';';
#start_symbol = (#ws #rule)* #ws;

#update_parser_table(#start_symbol)




//e.g. 
#bare_range = #expr ':' #expr;
#range = #bare_range | [(\[] #bare_range [)\]];

/{
Precedence levels
3 - group
3 - capture
3 - hexset/charset []

4 - star
4 - plus
4 - option
4 - compliment
5 - diff
5 - intersect
5 - union

7 - concatenation


8 - or



#what about restrictions / disambiguation filters?
- follow (no follow | must follow)
- reject
- prefer
- precedence level + associativity


}/