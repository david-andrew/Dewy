//lots of examples of different operators for testing parsing precedences
4y
(2+3)(x*2)
add(2, 3)result
push[1 2 3 4 5]
10 20 30 40 50
a b c d e
4, 5, 6
"apple", "banana", "cherry"
((3+5)^2(2*3))
((x+y)*z)
3 + 5 * 2
10 / 2 - 3
2 ^ 3 % 7
true and false or true
false nand true xor false
x =? 5
10 >? y
z <? 20
a >=? 15
b <=? 30
(x+3).length
(y * z).size
arr1 .* 2
arr2 .+ 5
result: int
age: float
1..5
[0..10)
[1, 3..15]
(3..7]
+3
-x
not y
@z
3?
x;
y...
x*+3
y/-4
z^/2
w^@3
(2x + 5)(3y - 4)
3a^2 - 4b + 5, 6c - 7
(-x * y / 2).length * (z+5)
print[1 2 3]x*2
(3+5, 2*3)range[0..10)
function(x: int, y: float): str
a =? 5 and b >=? 10
(sum[1 2 3] + product[4 5 6]) * 7
true xor (false or y >=? 3)
(((3 + 2x).area, y^2 * 10), (a, b, c))
[1, 3..9] .* (x+3)
myFunc@age: int, name: string;
(x^2 + y^2)^(1/2).magnitude
if (a >? b) and (c <=? d) result = 1 else result = 0
(4x^2 - 2, y+1 .^ 3, z^/4).tupleProduct
set[2x 3y 5z] : (int, float, string)
(((10..20, 25..30) .+ 5), (x-3..x+3))
obj.method1(3)method2(x*y, "str").property
not a =? b or c <? d nand e >=? f
sum[0, 2..10] * product[-5..5]/@2

// weird syntax but technically not a syntax error. possibly a type error though
mat[0,2..(4) [1..4) 1,3..]
mat[0,3..end [1..3) [1,2 4,5]]
mat[1,2,3 (0..end) [1,3..end)]

// lots of range examples
[1 .. 5]
[1 ..5]
[1.. 5]
[1..5]
mat[() [5 6] 3..]
mat[1.. [1..3)]
mat[[0 2] [1 3]]
mat[() 0,3..end 1,4]
mat[0..3 2..5]
mat[[0 2 4] 1..4 1,3..]
mat[0,3..end [1..3) [1 2 4 5]]
mat[1,2,3 [0..end) [1,3..end]]
mat[1 2 3 [0..end) [1,3..end]]
mat[() 0,3..end [1 4]]
mat[0,2..end 1..4 [0 2 4]]
mat[() 1..end 0,2..]
mat[[0 2 4] [1 3 5] (0..end) [3..6]]
mat[0,2.. [1..4) [1 3 5]]
mat[[0 3] [1 4] (0..end)]

// optional commas
mat[0,2..end 1..4 [0 2 4]]
mat[0, (1,3..end)]
mat[(0,2..end)]
mat(0,2..end)
mat[(0,2..end), [1 3 5]]
mat[[0,2..end), [1,3..end)]

// mathy range indices
mat[0..(end-1), (1,3..end/2)]
mat[(0,2*sqrt(2)..end) [1 3 5].*2]
mat[(0..end*0.75), 1..(end-2)]
mat[(1+1,2*2..end-1) [1 3 5] .- 1]
mat[(-3,3..end*0.9), [1 3] .* (end/2)]
mat[(0..end-1)/2 2..(end*0.5)]
mat[(0,3*sin(pi/3)..end-1), [1 3] + end/4]


//TODO: how to handle the fact that juxtapose has different precedence based on if its a function call vs a multiply?
sin(x)^2 + cos(x)^2  //-> exponent after function call
sin = 2 cos = 3
sin(x)^2 + cos(x)^2  //-> exponent before multiply...

2x^2 + 3x + 4
2(x)^2 + 3(x) + 4