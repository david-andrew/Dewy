///////////////////// STRING INTERPOLATION /////////////////////

/{Todo: probably break each section for different syntaxes into different files?}/

//silly example with keyword vs identifier
loop i i

r'this is a raw string \'  expr  'a separate string later'

// simple blocks
{   }
( /{comment inside}/ )
{ 2+2 }
( 2+2 )


//string interpolation
my_string = '2 + 2 = {2+2}'

//complex interpolation
s = "first 10 primes are: {
    primes = [2]
    (loop i in [3, 5..)
        if i .% primes :> product not =? 0 
            primes.push(i)
        if primes.length == 10
            break
    )
    primes
}"


//alternative prime generator + getting first 10 primes
primes = [
    2
    lazy i in [3, 5..)
        if i .% #self .=? 0 :> @reduce(, (prev, v) => prev and v)
            i
][..10)

//TBD if there is a parallel way to do this where the i .% primes dispatches each operation, and fails immediately on any returning false
primes = [
    2
    lazy i in [3, 5..)
        if not parallel_or(p => i % p =? 0, #self) 
            i
][..10)
//parallel or is like goroutines with cancel once any is true...should have it be more flexible, e.g. able to use any of the boolean keywords that can short circuit
//actually probably don't want to need to specify that it's parallel. Instead if there's an operation over a vector, it gets parallelized if possible.

//nested interpolation
s2 = 'this is an outer string, and {'this is an interior string with "{my_string}" in it'}'